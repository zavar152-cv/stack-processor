# **Стековый процессор**

- Абузов Ярослав Александрович P33302
- `forth | stack | harv | hw | tick | binary | stream | mem | prob1`

![GitLab CI](https://img.shields.io/badge/gitlab%20ci-%23181717.svg?style=for-the-badge&logo=gitlab&logoColor=white)
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=java&logoColor=white)

[![pipeline status](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/badges/master/pipeline.svg)](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/commits/master)
[![coverage report](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/badges/master/coverage.svg)](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/commits/master)

## **Язык программирования**

Форма Бэкуса-Наура для языка Zorth (Forth + Zavar30):

```
<base> ::= <words> | <function> <space> <base>
<word> ::= <number> | <command>
<words> ::= <word> <space> <words> | <loop> <space> <words> | <word>
<number> ::= [0-9]+
<command> ::= "+" | "-" | "*" | "/" | INC | DEC | "AND" | "OR" | "NEG" | "XOR" | "NOT" | "=" 
                  | "!=" | ">" | "<" | "SWAP" | "DROP" | "DUP" | "OVER" | "!" | "@" | "." 
                  | "EMIT" | "IN" | <var> | <name> | ".\"" <space> <string> | <if>
<function> ::= ":" <space> <name> <space> <words> <space> ";"
<loop> ::= "do" <space> <words> <space> "loop"
<if> ::= "if" <space> <words> <space> "endif"
<var> ::= "variable" <space> <name>
<string> ::= ([A-z] | [0-9])+ "\""
<name> ::= ([A-Z] | [a-z])+
<space> ::= " " | "\n"
```

- Основное свойство языка - запись всех действий в обратной польской нотации (т.е. 2 + 3 будет выглядеть так: 2 3 +). Основной объект действия команд - стек
- Имеется поддержка математических операторов, логических операторов, операторов сравнения, переменных, циклов, условных операторов и функций
- Все слова языка должны быть разделены пробелом или переносом строки
- Поддерживаются комментарии в формате // comment
- Все функции объявляются в самом начале программы, затем идёт основная программа
- Поддерживаются вложенные циклы и вложенные условные операторы
- Системы типов нет. Все представлено в виде целых чисел. Все команды оперируют со стеком целых чисел
- Переменные имеют глобальную область видимости (после объявления), можно объявить в любом месте программы

### **Детали языка. Положить число на стек**
Для того, чтобы положить число на стек - необходимо просто написать его. По своей сути - числовой литерал

_Пример:_ `6`, теперь 6 лежит на верхушке.

### **Детали языка. Функции**
Для объявления функции необходимо использовать следующий синтаксис: `": <имя> <тело> ;"`. 

_Пример:_ `: sumn d @ n @ d @ / DUP 1 + * * 2 / ;`

Внутри одной функци объявить другую нельзя. Для вызова функции необходимо написать ей имя, например: `ADD sumn 2 3`.

### **Детали языка. Переменные**
Для объявления переменной необходимо использовать следующий синтаксис: `"variable <имя>"`.

_Пример:_ `variable a`

Для получения адреса переменной необходимо написать её имя, на верхушке стека будет адрес переменной.

Для получения значения необходимо использовать следующий синтаксис: `"<имя> @"`. @ - оператор fetch.

_Пример:_ `a @`, теперь значение переменной лежит на верхушке стека.

Для записи значения необходимо использовать следующий синтаксис: `"<значение> <имя> !"`. ! - оператор store. Т.е. значение берется из верхушки стека.

_Пример:_ `15 a !`, теперь 15 хранится в переменной `a`.

### **Детали языка. Циклы**
Цикл будет повторять команды заключенные между `do ... loop`, пока на верхушке стека не 0. Вложенные циклы разрешены.

_Пример:_ `do 2 3 ADD loop`

_Пример:_ `do 1 IN EMIT loop` - бесконечный цикл из программы cat.

### **Детали языка. Условные операторы**
Будут выполнены команды внутри `if ... endif`, если на верхушке стека не 0. Вложенные `if` разрешены.

_Пример:_ `if 4 1 AND if OR * endif = endif`

### **Детали языка. Ввод-вывод**
Для ввод-вывода существуют специальные команды: `.`, `EMIT`, `IN`. Их описание ниже.

Для вывода строкового литерала существует специальная команда `."`. Она выводит идущий за ней строковый литерал.

_Пример:_ `." Hello world!"` - вывести Hello world!, ковычка в конце нужна для обозначения строкового литерала.

### **Детали языка. Описание команд**
| Команда | Стек | Описание |
| ------ | ------ | ------ | 
| + | N1 N2 → (N1 + N2) | Складывает два первых операнда и возвращает сумму на вершину |
| \- | N1 N2 → (N1 \- N2) | Вычитает N1 из N2 и возвращает разность на вершину | 
| \* | N1 N2 → (N1 \* N2) | Умножает два первых элемента и возвращает произведение на вершину |
| / | N1 N2 → (N1 / N2) | Делит N1 на N2 и возвращает целую часть на вершину |
| AND | N1 N2 → (N1 & N2) | Побитовое логическое умножение N1 и N2 |
| OR | N1 N2 → (N1 \| N2) | Побитовое логическое сложение N1 и N2 |
| NEG | N1 → -N1 | Отрицание N1 |
| XOR | N1 N2 → (N1 ^ N2) | «Cложение по модулю 2» N1 и N2 |
| NOT | N1 → !N1 | Побитовое логическое отрицание N1 |
| = | N1 N2 → (N1 == N2) | Проверка на равенство N1 и N2. Если равны, то результат 1, иначе 0 |
| != | N1 N2 → (N1 != N2) | Проверка на неравенство N1 и N2. Если неравны, то результат 1, иначе 0 |
| > | N1 N2 → (N2 > N1) | Проверка, что N2 больше N1. Если так, то результат 1, иначе 0 |
| < | N1 N2 → (N2 < N1) | Проверка, что N2 меньше N1. Если так, то результат 1, иначе 0 |
| INC | N1 → (N1 + 1) | Инкремент N1 |
| DEC | N1 → (N1 - 1) | Декремент N1 |
| SWAP | N1 N2 → N2 N1 | Меняет местами два верхних элемента стека |
| DROP | N1 N2 → N1 | Удаляет N1 из стека |
| DUP | N1 → N1 N1 | Копирует N1 на вершину |
| OVER | N1 N2 → N1 N2 N1 | N1 N2 → N1 N2 N1 |
| ! | N1 ADDR → | Сохраняет N1 по адресу ADDR в памяти данных |
| @ | ADDR → N1 | Считывает значение из памяти данных по адресу ADDR и возвращает его в N1 на вершину |
| . | N1 → | Выводит вершину стека в output |
| EMIT | N1 → | Выводит вершину стека в output как символ |
| IN | → N1 | Считывает значение из input |

## **Организация памяти**
### **Как язык позволяет работать с памятью**
- Язык работает со стеком и с памятью данных
- Как таковых именованных констант нет
- Существуют числовые и строковые литералы (см. детали языка выше)
- Возможно объявить переменную (см. детали языка выше)
- Возможно получить адрес (ссылку) переменной (см. детали языка выше)
- Вся память статическая, динамического выделения нет
- Scope всех переменных - глобальный

### **Модель памяти процессора**
Память разделена на две группы - стековая и обычная. Стековая память существует в двух видах: стек данных и стек возврата. Первый используется для вычислений (машинное слово 32 бита, знаковое), второй для хранения адресов возврата из функций (машинное слово 32 бита, беззнаковое). У стека данных вершина вынесена в отдельных регистр `TOS`, а второй элемент стека находится в самом стеке на его вершине. Реализованы с помощью Stack.

Модель обычной памяти - Гарвардская т.е. разделена на память данных и память программы. Память программы является read-only после записи в нее программы. 

- Память программы: 16777215 (2^24 - 1) ячеек, машинное слово 32 бита, беззнаковое. Адресное пространство линейное, реализовано с помощью ArrayList.
- Память данных: 4096 ячеек, машинное слово 32 бита, знаковое. Адресное пространство линейное, реализовано с помощью ArrayList.

_P.S. Адрес задаётся 24 битами, поэтому его максимальное значение (2^24 - 1). Память данных ограничена только этим значением, поэтому легко может быть расширена. Размер в 4096 ячеек был выбран для уменьшения потребляемой памяти симулятора_

### **Как транслятор отображает конструкции языка на память**
В памяти данных сначала идут литералы, затем переменные. Однако первых три адреса занято под IO. 

В памяти команд сначала идёт основная программа, затем идут функции. Основная программа обязательно заканчивается HALT.

```
Data memory
+-----------------------------+
| 00  : IO byte out           |
| 01  : IO in                 |
| 02  : IO char out           |
| 03  : lit 1                 |
| 04  : lit 2                 |
|    ...                      | 
| n   : var 1                 |
| n+1 : var 2                 |
|    ...                      |
| 4096: end of data memory    |
+-----------------------------+

Program memory
+-----------------------------+
| 00  : main program start    |
|    ...                      |
| n   : end of main program   |
| n+1 : function 1 start      |
|    ...                      |
| k   : end of function 1     |
| k+1 : function 2 start      |
|    ...                      |
| m   : end of function 2     |
+-----------------------------+
```

## **Система команд**
### **Особенности процессора**

- ALU
    - Имеет два входа (левый и правый) и один выход. Выбираются через мультиплексоры и соотв. сигналы
    - Поддерживает множество операций ([Alu.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/processor/src/main/java/ru/itmo/zavar/alu/Alu.java)), которые выбираются с помощью сигнала
- Data stack
    - Можно положить на стек или снять с него значение
    - Регистр DS (32 бита) содержит второй сверху элемент
    - Регистр TOS (32 бита) содержит вершину стека
- Return stack
    - Можно положить на стек или снять с него значение
    - Регистр RS (32 бита) содержит вершину стека
- Data memory
    - Можно записать или считать значение по адресу
    - Регистр DMAR (24 бита) отображает адрес
    - Первые три ячейки отведены для IO (0 - байтовый вывод, 1 - ввод, 2 - символьный вывод)
    - Определением с чем работать - с IO или памятью - занимается контроллер памяти ([DataMemoryController.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/processor/src/main/java/ru/itmo/zavar/base/mem/DataMemoryController.java))
- Program memory
    - Можно считывать команды по адресу (read-only)
    - Регистр PMAR (24 бита) отображает адрес
    - PMAR связан с регистром IP (24 бита)
    - Значение команды попадает сразу в регистр CR (32 бита)
- Регистр AR (address registry)
    - 24 бита, беззнаковый
    - Хранит адрес, нужен для адресных инструкций
    - Связан с CR 
- Регистр IP (instruction pointer)
    - 24 бита, беззнаковый
    - Указывает на следующую инструкцию
    - Связан с PMAR
- Регистр TOS (top of stack)
    - 32 бита, знаковый
    - Хранит вершину Data stack
    - Можно посмотреть знак (флаг N) и равен ли он нулю (флаг Z)
- Регистр TC (tick counter)
    - Считает тики во время этапов исполнения команд
    - Нужен в первую очередь для отладки

Все соединения отображены на схеме.

### **Цикл выполнения инструкции**
Цикл состоит из трёх этапов:
- Fetch next instruction (загрузка следующей инструкции)
    - PMAR ← IP
    - СR ← PMEMORY
    - IP ← IP + 1
- Fetch address (загрузка адреса из кода инструкции в AR, если инструкция адресная)
    - AR ← CR (0..23)
- Execute (выполнение)
    - Такты самой инструкции

### **Кодирование инструкций**
Формат кодирования - бинарный. Слово - 32 бита, беззнаковое.

Старшие 8 бит отведены под код команды, при этом 7й бит отведен под тип команды. 0 - команда безадресная. 1 - команда адресная. Младшие 24 бита отведены под адрес в адресный командах, в безадресных эти биты равны 0.

### **Система команд**

В бинарном формате указаны только старшие 8 бит. Про младшие 24 бита описано выше.

| Мнемоника | Бинарный формат | Кол-во тактов | Описание |
| ------ | ------ | ------ | ------ |
| HALT | 00000000 | 1 | Останов |
| ADD | 00000010 | 1 | см. язык |
| SUB | 00000100 | 1 | см. язык |
| MUL | 00000110 | 1 | см. язык |
| DIV | 00001000 | 1 | см. язык |
| AND | 00001010 | 1 | см. язык |
| OR | 00001100 | 1 | см. язык |
| NEG | 00001110 | 1 | см. язык |
| XOR | 00010000 | 1 | см. язык |
| EQ | 00010010 | 1 | см. язык (=) |
| GR | 00010100 | 1 | см. язык (>) |
| LE | 00010110 | 1 | см. язык (<) |
| DROP | 00011000 | 1 | см. язык |
| DUP | 00011010 | 1 | см. язык |
| OVER | 00011110 | 4 | см. язык |
| SWAP | 00100000 | 3 | см. язык |
| >R | 00100010 | 2 | Поместить веришну DS на RS |
| R> | 00100100 | 2 | Поместить веришну RS на DS |
| ! | 00100110 | 3 | см. язык |
| @ | 00101000 | 2 | см. язык |
| [LIT] addr | 00101011 | 3 | Загрузить литерал на вершину по адресу |
| [JMP] addr | 00101101 | 1 | Безусловный переход по адресу |
| [IF] addr | 00101111 | 2/1 | Переход по адресу, если на вершине 0 |
| [CALL] addr | 00110001 | 2 | Вывзов функции по адресу |
| [LOOP] addr | 00110011 | 2/1 | Переход по адресу пока на вершине не 0 |
| NOPE | 00110100 | 1 | Нет операции |
| EXIT | 00110110 | 1 | см. язык |
| NOT | 00111000 | 1 | см. язык |
| [ADDR] addr | 00111011 | 2 | Загрузить адрес из AR в TOS |
| INC | 00111100 | 1 | см. язык |
| DEC | 00111110 | 1 | см. язык |
| NEQ | 01000000 | 1 | см. язык |

Подробнее [InstructionCode.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/common/src/main/java/ru/itmo/zavar/InstructionCode.java)

## **Транслятор**
Реализовано здесь: [ZorthTranslator.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/translator/src/main/java/ru/itmo/zavar/zorth/ZorthTranslator.java)

Интерфейс командной строки:
```
usage: translator.jar
 -d,--debug <arg>    debug
 -f,--format <arg>   output file format
 -i,--input <arg>    input file path
 -o,--output <arg>   output path
```

Глобально трансляция проходит за два этапа: компиляцию и линковку.

1. Компиляция
    - Проход по всей исходной программе
    - Преобразование примитивов Zorth в инструкции процессора (правила ниже)
    - Формирование таблиц линковки для функций, литералов и переменных с 0 адресами
    - Установка заглущек с метками на адресные команды
    - Разделение кода функций и основной программы
    - Проверка синтаксических ошибок и вывод сообщений о них
2. Трансляция
    - Установка адресов в таблицах линковки
    - Размещение в памяти литералов и переменных
    - Установка валидных адресов вместо заглушек в основной программе
    - Соединение основной программы и функций

Пример скомпилированной части программы:
```
[CALL] fun$sumn
[LIT] lit$5
[ADDR] var$d
! 
[CALL] fun$sumn
ADD 
[LIT] lit$3
[LIT] lit$5
MUL 
[ADDR] var$d
! 
[CALL] fun$sumn
SUB
```

Пример слинкованной части программы:
```
[CALL] 26
[LIT] 6
[ADDR] 7
! 
[CALL] 26
ADD 
[LIT] 5
[LIT] 6
MUL 
[ADDR] 7
! 
[CALL] 26
SUB 
```
### **Правила трансляции**

- Примитивы Zorth могут быть отражены в команды процессора 1:1 (например, '+', '-', 'AND') или 1:N ('.', 'EMIT').
- В конце основной программы HALT
- В конце функций EXIT
- Для загрузки литерала lit$n - n - адрес литерала в памяти данных
- Для переменной var$n - n - адрес переменной в памяти данных
- Для функции fun$n - n - адрес прыжка в памяти программы
- Для цикла loop$n - n - насколько шагов назад необходимо прыгуть относительно [LOOP] в памяти программы т.е. адрес будет равен адрес ([LOOP] - n)
- Для условий if$n - n - адрес в памяти программы на который нужно прыгнуть в случае 0 на вершине

Итоговая программа может быть упакована в бинарный формат или текстовый формат с мнемониками.

## **Модель процессора**
### **DataPath**
<img src="img/DataPath.png" alt="dataPath"/>

Реализовано здесь: [DataPath.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/processor/src/main/java/ru/itmo/zavar/comp/DataPath.java)

Составные компоненты описаны выше.

Сигналы (выполняются за один такт):
- С префиксом oe - сигнал output enable для соотв. памяти
- С префиксом wr - сигнал на запись для соотв. памяти или регистра
- С префиксом rd - сигнал на чтение соотв. регистра
- sel-lalu - выбор левого входа ALU
- sel-ralu - выбор правого входа ALU
- sel-out - выбор выхода ALU
- sel-op - выбор операции ALU

Сигналы реализованы с помощью методов в классе [DataPath.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/processor/src/main/java/ru/itmo/zavar/comp/DataPath.java). Мультиплексоры реализованы с помощью enum здесь [mux](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/tree/master/processor/src/main/java/ru/itmo/zavar/base/mux).

Флаги:
- Z - проверить TOS на 0
- N - знак TOS 


### **ControlUnit**
<img src="img/ControlUnit.png" alt="controlUnit"/>

Реализовано здесь: [ControlUnit.java](https://gitlab.se.ifmo.ru/Zavar30/stack-processor/-/blob/master/processor/src/main/java/ru/itmo/zavar/comp/ControlUnit.java)

Составные компоненты описаны выше. Цикл выполнения команды описан выше. Класс предоставляет доступ к журналу моделирования, где можно посмотреть программно каждый тик и состояние каждого регистра и т.д.

Сигналы (выполняются за один такт):
- С префиксом wr - сигнал на запись для соотв. памяти или регистра
- С префиксом rd - сигнал на чтение соотв. регистра
- fetch - считать из программной памяти и поместить в CR
- fetch-ar - поместить из CR в AR адрес
- inc-tick - инкрементировать TC
- reset-tick - сбросить TC

### **Интерфейс командной строки**
```
usage: processor.jar
 -d,--data <arg>      data path
 -dg,--debug <arg>    debug
 -i,--input <arg>     input path
 -p,--program <arg>   program path
```
